#IL

提到IL，我们知道这是.NET Framework的核心，IL语言有如下特性：

1. 面向对象和接口
2. 值类型和引用类型的区分（装箱和拆箱）
3. 强数据类型
4. Exception错误处理
5. Attributes

##支持面向对象和接口
.NET面向对象的语言实现需要有一定的限制条件，IL需要实现特定的编程条件，架构在IL上面的语言也需要遵守这些
条件，微软选择了经典的面向对象的编程方式，兼容接口类型。

面向对象中IL引入的接口概念是在COM组件编程中为我们熟知的，但.NET内置的接口又与COM接口不太一样，.NET接口
不需要支持COM架构，不需要继承IUnkonwn接口，他们共享一个定义契约的语法原则，使用class继承并实现此原则，从而支持了C#中的多态等语法特性，.NET中继承自接口的类必须完全实现接口中定义的方法。

##值类型和引用类型

众所周知的，值类型在内存中的栈区，引用类型在内存中的堆区。

##强数据类型

IL架构在强数据类型基础上，所以每个变量在定义时必须定义出其类型，IL禁止产生模糊数据类型。VB6中数据类型支持自动转换，C++通过指针的方式进行数据转换，虽然定义强数据类型会有一定的性能上的损失，但其提供的便利之处远大于其性能损失（现在不都是提倡用空间换时间么）

* 语言互操作
* 垃圾回收
* 数据安全
* 应用程序域

### 强数据类型是语言互操作的关键

试想一下，如果我们用vb定义了一个方法，返回vb中的integer类型，现在我们用C#来调用这个方法，我们如何知道vb中这个方法返回值呢？我们又该如何使用呢？ IL中的强数据类型解决了这个问题

*通用类型系统CTS*

通用类型系统CTS很简单，就是在IL中预定义强数据类型，所有编译为IL的语言都需要有类型的映射，所以vb中的integer映射为IL中的Int32，C#中的int类型映射为Int32。

CTS定义了类型的层次结构，这个层次结构如下：
![CTS 层次结构](1.png)

*通用语言规范CLS*

通用语言规范CLS和通用类型系统共同确保了语言的互操作性，CLS定义了一系列的标准，所有需要编译为IL的语言都需要遵守这些标准 然后举了个我没懂的区分大小写的例子...

1. 编译器不必要实现所有的CLS功能，只需要实现CLS的子集。
2. 实现CLS的编译器能够在.NET平台上编译通过并且被其他语言调用。

限制你的是使用public和protected定义的class和method，因为使用private定义的代码外部代码不能够调用到，所以你在private中可以充分利用语言特性为所欲为。

*垃圾回收*

.NET中垃圾回收是自动处理的，实现自动处理的垃圾回收有两种方式：

1. 在代码中显示指明释放内存
2. 内存中的[引用计数器](https://en.wikipedia.org/wiki/Reference_counting)保持对对象的引用

乍听起来，觉得可能不太理解，代码中显示指明释放内存这种事情对于.NET的开发人员来说不太常见，通常在引用一个第三方组件的时候使用，例如对于Office文档的操作类，继承IDispose接口，引用计数器则是指内存中的一个维持对象、数组的一个指针数组，动态检测此对象在运行过程中是否还会继续使用，如果不继续使用，则释放此对象，so... 过多的时候静态类型可能导致内存的膨胀。

很多时候，类似于C++这种手动释放内存的语言在性能上有很大的优势，但同时又要求你非常牛逼，如果没有释放内存，很容易造成内存泄漏。虽然现在的开发者有很多工具能够检测内存泄漏情况，但这些检测条件是内存泄漏已经发生才能够检测，这时候你的宿主机必然已经卡出翔。

COM一直使用引用计数器，但是COM使用的方式更加具有风险，内存的释放取决于引用计数器是否已经清空，如果还有数值，就不能清空，而调用了引用计数器的客户端在释放的时候还必须通知引用计数器已经取消，如果有一台客户端没有清空，比如一个应用程序调用了COM，而这个应用程序一直驻留在内存中，很可能导致内存泄漏。

所谓天下文章一大抄，就看你会抄不会抄，.NET的垃圾回收和Java非常类似，使用同样的原理，所有动态请求的内存都在堆上，当然，CLR有自己的托管堆，这个我们不用管，我们只要知道当应用程序进程已经达到需要检测的临界标准，.NET会调用垃圾回收器，垃圾回收器检测堆中的对象引用在代码以后的定义执行过程中是否还会用到，其实如果需要用到的话，一定保留着对这个对象的引用，如果没有，就移除此对象，释放内存。

为了保证类型安全，IL在获取内存计数器的时候只能够获取到内存计数器的备份，并不能获取到原始值，并且垃圾回收器这种工具不是能够确定什么是否调用的，也就是你没办法寻找到一个规律来确定使用垃圾回收期，CLR会自动根据内存使用情况决定什么时候调用。

*安全*

.NET的代码安全的机制不同于Windows安全机制，Windows的安全是基于角色的，也就是不同用户的登录，会产生不同的影响，例如通常情况下administrator和普通用户的差别很大，有些操作如访问注册表、停止线程等操作需要administrator来操作,.NET是基于代码的安全机制，所谓的基于代码的安全机制也就是就算你基于管理员登录，但只要我检测到你代码里面强类型不匹配，操作注册表，反射工具等问题，我都可以实施代码安全策略。

###应用程序域

事实上，应用程序域很大程度上提高了应用程序的性能，设想一下，我们以前的程序都运行在单独的进程中，不同的进程彼此之间如果访问会造成很大的性能开销，不同进程之间的数据访问有两种形式，分别是复制数据和远程访问，复制数据就是将要访问的数据拷贝到另一进程，从而能够访问。还有一种形式是通过远程调用，也就是给另一进程一个当前数据进程的token，拿到token以后就可以调用本进程的数据。是的，你看到的就是这种形式，十分耗费资源是不是？

我们先来讨论下进程的内存调用方式，进程彼此之间是独立的，独立进程的实现是通过地址空间实现的，每个进程拥有4GB的虚拟内存，用来存储数据和执行代码（64位操作系统高于4GB），每个虚拟内存的地址空间其实是映射到实际的物理内存，从而实现进程隔离

